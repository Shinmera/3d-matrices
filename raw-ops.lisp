#|
 This file is a part of 3d-matrices
 (c) 2022 Shirakumo http://tymoon.eu (shinmera@tymoon.eu)
 Author: Nicolas Hafner <shinmera@tymoon.eu>
|#

(in-package #:org.shirakumo.fraf.matrices)

(define-template mapply <s> <t> (x m f)
  (let ((type (type-instance 'mat-type <s> <t>)))
    `((declare (type ,(lisp-type type) x m)
               (type (function (,<t>) real) f)
               (return-type ,(lisp-type type))
               inline)
      (let ((ma ,(place-form type 'arr 'm))
            (xa ,(place-form type 'arr 'x)))
        (do-times (i 0 ,(attribute type :len) 1 x)
          (setf (aref xa i) (,<t> (funcall f (aref ma i)))))))))

(define-template mvec <s> <t> (m)
  (when (eql <s> 'n) (template-unfulfillable))
  (let ((type (type-instance 'vec-type <s> <t>)))
    `((declare (ignore m)
               (return-type ,(lisp-type type))
               inline)
      (,(lisp-type type)))))

(define-template copy <s> <t> (m)
  (let ((type (type-instance 'mat-type <s> <t>)))
    `((declare (type ,(lisp-type type) m)
               (return-type ,(lisp-type type))
               inline)
      (let ((orig ,(place-form type 'arr 'm))
            (arr (make-array ,(attribute type :len) :element-type ',<t>)))
        (do-times (i 0 ,(attribute type :len))
          (setf (aref arr i) (aref orig i)))
        (,(constructor type) arr ,@(when (eql 'n <s>) `(,(place-form type 'cols 'm)
                                                        ,(place-form type 'rows 'm))))))))

(define-template smatop <op> <st> <s> <t> (x m s)
  (let ((type (type-instance 'mat-type <s> <t>)))
    `((declare (type ,(lisp-type type) x m)
               (type ,(case <st> (<t> <t>) (T <st>)) s)
               (return-type ,(lisp-type type))
               inline)
      (let ((ma ,(place-form type 'arr 'm))
            (xa ,(place-form type 'arr 'x))
            (s (,<t> s)))
        (do-times (i 0 ,(attribute type :len) 1 x)
          (setf (aref xa i) (,<op> (aref ma i) s)))))))

(define-template 2matop <op> <s> <t> (x m n)
  (let ((type (type-instance 'mat-type <s> <t>)))
    `((declare (type ,(lisp-type type) x m n)
               (return-type ,(lisp-type type))
               inline)
      (let ((ma ,(place-form type 'arr 'm))
            (na ,(place-form type 'arr 'n))
            (xa ,(place-form type 'arr 'x)))
        (do-times (i 0 ,(attribute type :len) 1 x)
          (setf (aref xa i) (,<op> (aref ma i) (aref na i))))))))

(define-template 1matop <op> <s> <t> (x m)
  (let ((type (type-instance 'mat-type <s> <t>)))
    `((declare (type ,(lisp-type type) x m)
               (return-type ,(lisp-type type))
               inline)
      (let ((ma ,(place-form type 'arr 'm))
            (xa ,(place-form type 'arr 'x)))
        (do-times (i 0 ,(attribute type :len) 1 x)
          (setf (aref xa i) (,<op> (aref ma i))))))))

(define-template 0matop <op> <s> <t> (x)
  (let ((type (type-instance 'mat-type <s> <t>)))
    `((declare (type ,(lisp-type type) x)
               (return-type ,(lisp-type type))
               inline)
      (let ((xa ,(place-form type 'arr 'x)))
        (do-times (i 0 ,(attribute type :len 'x) 1 x)
          (multiple-value-bind (y x) (floor i ,(attribute type :cols 'x))
            (setf (aref xa i) (,<t> (,<op> x y)))))))))

(define-template 2matreduce <red> <comb> rtype <s> <t> (m n)
  (let ((type (type-instance 'mat-type <s> <t>))
        (rtype (case rtype
                 (<t> <t>)
                 (float (case <t> (f64 'f64) (T 'f32)))
                 (T rtype))))
    `((declare (type ,(lisp-type type) m n)
               (return-type ,rtype)
               inline)
      (let* ((ma ,(place-form type 'arr 'm))
             (na ,(place-form type 'arr 'n))
             (r (,<comb> (aref ma 0) (aref na 0))))
        (do-times (i 1 ,(attribute type :len) 1 r)
          (setf r (,<red> r (,<comb> (aref ma i) (aref na i)))))))))

(define-template 1matreduce <red> <comb> rtype <s> <t> (m)
  (let ((type (type-instance 'mat-type <s> <t>))
        (rtype (case rtype
                 (<t> <t>)
                 (float (case <t> (f64 'f64) (T 'f32)))
                 (T rtype))))
    `((declare (type ,(lisp-type type) m)
               (return-type ,rtype)
               inline)
      (let* ((ma ,(place-form type 'arr 'm))
             (r (,<comb> (aref ma 0))))
        (do-times (i 1 ,(attribute type :len) 1 r)
          (setf r (,<red> r (,<comb> (aref ma i)))))))))

(define-template smatreduce <red> <comb> <st> rtype <s> <t> (m s)
  (let ((type (type-instance 'mat-type <s> <t>))
        (rtype (case rtype
                 (<t> <t>)
                 (float (case <t> (f64 'f64) (T 'f32)))
                 (T rtype))))
    `((declare (type ,(lisp-type type) m)
               (type ,(case <st> (<t> <t>) (T <st>)) s)
               (return-type ,rtype)
               inline)
      (let* ((ma ,(place-form type 'arr 'm))
             (s (,<t> s))
             (r (,<comb> (aref ma 0) s)))
        (do-times (i 1 ,(attribute type :len))
          (setf r (,<red> r (,<comb> (aref ma i) s))))
        (,(if (member rtype '(f32 f64 i32 u32)) rtype 'progn) r)))))

(define-template m*m <s> <t> (x m n)
  (let ((type (type-instance 'mat-type <s> <t>)))
    `((declare (type ,(lisp-type type) x m n)
               (return-type ,(lisp-type type)))
      (let ((ma ,(place-form type 'arr 'm))
            (na ,(place-form type 'arr 'n))
            (xa ,(place-form type 'arr 'x))
            (mc ,(attribute type :cols 'm))
            (nc ,(attribute type :cols 'n))
            (xi 0) (mi 0))
        (do-times (xy 0 ,(attribute type :rows 'x) 1 x)
          (do-times (xx 0 ,(attribute type :cols 'x) 1)
            (let ((c (,<t> 0))
                  (mi mi)
                  (ni xx))
              (do-times (i 0 ,(attribute type :cols 'm) 1)
                (setf c (,<t> (+ c (* (aref ma mi) (aref na ni)))))
                (incf ni nc)
                (incf mi 1))
              (setf (aref xa xi) c)
              (incf xi)))
          (incf mi mc))))))

(define-template m*v <vs> <s> <t> (x m n)
  (when (member <s> '(n)) (template-unfulfillable))
  (unless (or (eql <s> <vs>) 
              (and (eql <s> 4) (eql <vs> 3))
              (and (eql <s> 3) (eql <vs> 2)))
    (template-unfulfillable))
  (let ((type (type-instance 'mat-type <s> <t>))
        (vtype (type-instance 'vec-type <vs> <t>)))
    `((declare (type ,(lisp-type type) m)
               (type ,(lisp-type vtype) x n)
               (return-type ,(lisp-type vtype)))
      (let ((ma ,(place-form type 'arr 'm))
            (na ,(place-form vtype 'arr 'n))
            (xa ,(place-form vtype 'arr 'x))
            (mi 0))
        (do-times (xy 0 ,<vs> 1 x)
          (let ((c (,<t> 0)))
            ,@(loop for xx from 0 below <vs>
                    collect `(setf c (,<t> (+ c (* (aref ma mi) (aref na ,xx)))))
                    collect `(incf mi 1))
            ,@(loop for xx from <vs> below <s>
                    collect `(setf c (,<t> (+ c (aref ma mi))))
                    collect `(incf mi 1))
            (setf (aref xa xy) c)))))))

(define-template mdet <s> <t> (m)
  (let ((type (type-instance 'mat-type <s> <t>)))
    `((declare (type ,(lisp-type type) m)
               (return-type ,<t>))
      (let ((ma ,(place-form type 'arr 'm)))
        ,(case <s>
           ;; FIXME: This *sucks*. Can't we compute this expansion?
           (2 `(macrolet ((e (y x) `(aref ma (+ ,x (* ,y 2)))))
                 (- (* (e 0 0) (e 1 1))
                    (* (e 0 1) (e 1 0)))))
           (3 `(macrolet ((e (y x) `(aref ma (+ ,x (* ,y 3)))))
                 (- (+ (* (e 0 0) (e 1 1) (e 2 2))
                       (* (e 0 1) (e 1 2) (e 2 0))
                       (* (e 0 2) (e 1 0) (e 2 1)))
                    (+ (* (e 0 0) (e 1 2) (e 2 1))
                       (* (e 0 1) (e 1 0) (e 2 2))
                       (* (e 0 2) (e 1 1) (e 2 0))))))
           (4 `(macrolet ((e (y x) `(aref ma (+ ,x (* ,y 4)))))
                 (- (+ (* (e 0 3) (e 1 2) (e 2 1) (e 3 0)) (* (e 0 0) (e 1 1) (e 2 2) (e 3 3))
                       (* (e 0 1) (e 1 3) (e 2 2) (e 3 0)) (* (e 0 2) (e 1 1) (e 2 3) (e 3 0))
                       (* (e 0 2) (e 1 3) (e 2 0) (e 3 1)) (* (e 0 3) (e 1 0) (e 2 2) (e 3 1))
                       (* (e 0 0) (e 1 2) (e 2 3) (e 3 1)) (* (e 0 3) (e 1 1) (e 2 0) (e 3 2))
                       (* (e 0 0) (e 1 3) (e 2 1) (e 3 2)) (* (e 0 1) (e 1 0) (e 2 3) (e 3 2))
                       (* (e 0 1) (e 1 2) (e 2 0) (e 3 3)) (* (e 0 2) (e 1 0) (e 2 1) (e 3 3)))
                    (+ (* (e 0 2) (e 1 3) (e 2 1) (e 3 0)) (* (e 0 3) (e 1 1) (e 2 2) (e 3 0))
                       (* (e 0 1) (e 1 2) (e 2 3) (e 3 0)) (* (e 0 3) (e 1 2) (e 2 0) (e 3 1))
                       (* (e 0 0) (e 1 3) (e 2 2) (e 3 1)) (* (e 0 2) (e 1 0) (e 2 3) (e 3 1))
                       (* (e 0 1) (e 1 3) (e 2 0) (e 3 2)) (* (e 0 3) (e 1 0) (e 2 1) (e 3 2))
                       (* (e 0 0) (e 1 1) (e 2 3) (e 3 2)) (* (e 0 2) (e 1 1) (e 2 0) (e 3 3))
                       (* (e 0 0) (e 1 2) (e 2 1) (e 3 3)) (* (e 0 1) (e 1 0) (e 2 2) (e 3 3))))))
           (T
            `(multiple-value-bind (LU P s) (mlu m)
               (declare (ignore P))
               (let ((rows (mrows LU))
                     (cols (mcols LU))
                     (arr (marr LU)))
                 (loop for det = (,<t> 0) then (* (expt -1.0 s) det (aref arr (+ i (* i cols))))
                       for i from 0 below rows
                       finally (return det))))))))))

(define-template mtranspose <s> <t> (x m)
  (let ((type (type-instance 'mat-type <s> <t>)))
    `((declare (type ,(lisp-type type) x m)
               (return-type ,(lisp-type type))
               inline)
      (let ((ma ,(place-form type 'arr 'm))
            (xa ,(place-form type 'arr 'x))
            (xc ,(attribute type :cols 'm)))
        (do-times (y 0 ,(attribute type :cols) 1 x)
          (do-times (x 0 ,(attribute type :rows) 1)
            (setf (aref xa (+ y (* x xc))) (aref ma (+ x (* y xc))))))))))

(define-template mtrace <s> <t> (m)
  (let ((type (type-instance 'mat-type <s> <t>)))
    `((declare (type ,(lisp-type type) m)
               (return-type ,<t>)
               inline)
      (let ((ma ,(place-form type 'arr 'm))
            (r (,<t> 0)))
        (do-times (i 0 (expt 2 (min ,(attribute type :cols) ,(attribute type :rows))) (1+ ,(attribute type :cols)) r)
          (setf r (+ r (aref ma i))))))))

(define-template mminor <s> <t> (m y x)
  (let ((type (type-instance 'mat-type <s> <t>))
        (itype (type-instance 'mat-type (case <s> (3 2) (4 3) (T 'n)) <t>)))
    `((declare (type ,(lisp-type type) m)
               (type dimension y x)
               (return-type ,<t>))
      (let* ((c ,(attribute type :cols 'm))
             (r ,(attribute type :rows 'm))
             (s ,(case (first (template-arguments itype))
                   (n `(,(lisp-type itype) (1- c) (1- r)))
                   (T `(,(lisp-type itype)))))
             (sa (marr s))
             (ma ,(place-form type 'arr 'm)))
        (declare (dynamic-extent s))
        (macrolet ((s (y x) `(aref sa (+ ,x (* ,y (1- c)))))
                   (m (y x) `(aref ma (+ ,x (* ,y c)))))
          ;; Copy the four subregions
          (do-times (i 0 y)
            (do-times (j 0 x)
              (setf (s i j) (m i j)))
            (do-times (j (1+ x) c)
              (setf (s i (1- j)) (m i j))))
          (do-times (i (1+ y) r)
            (do-times (j 0 x)
              (setf (s (1- i) j) (m i j)))
            (do-times (j (1+ x) c)
              (setf (s (1- i) (1- j)) (m i j))))
          (,(compose-name #\/ 'mdet (first (template-arguments itype)) <t>) s))))))

(define-template mcof <s> <t> (r m)
  (let ((type (type-instance 'mat-type <s> <t>)))
    `((declare (type ,(lisp-type type) m r)
               (return-type ,(lisp-type type)))
      (let* ((ra ,(place-form type 'arr 'r))
             (i 0))
        (do-times (y 0 ,(attribute type :rows 'm) r)
          (do-times (x 0 ,(attribute type :cols 'm))
            (setf (aref ra i) (* (,(compose-name #\/ 'mminor <s> <t>) m y x)
                                 (if (evenp (+ y x)) +1 -1)))
            (incf i)))))))

(define-template minv-affine <s> <t> (x m)
  (unless (eql 4 <s>) (template-unfulfillable))
  (let ((type (type-instance 'mat-type <s> <t>)))
    `((declare (type ,(lisp-type type) m x)
               (return-type ,(lisp-type type)))
      (let ((ma ,(place-form type 'arr 'm))
            (xa ,(place-form type 'arr 'x)))
        (macrolet ((e (y x) `(aref ma (+ ,x (* ,y 4))))
                   (f (y x) `(aref xa (+ ,x (* ,y 4)))))
          ;; Transpose the 3x3 rotation matrix
          ,@(loop for x from 0 below 3
                  append (loop for y from 0 below 3
                               collect `(setf (f ,y ,x) (e ,x ,y))))
          ;; Transpose the translation vector
          (let ((x (- (e 0 3)))
                (y (- (e 1 3)))
                (z (- (e 2 3))))
            (setf (f 0 3) (,<t> (+ (* x (e 0 0)) (* y (e 0 1)) (* z (e 0 2)))))
            (setf (f 1 3) (,<t> (+ (* x (e 1 0)) (* y (e 1 1)) (* z (e 1 2)))))
            (setf (f 2 3) (,<t> (+ (* x (e 2 0)) (* y (e 2 1)) (* z (e 2 2))))))
          ;; Fill the last row
          (setf (f 3 0) (,<t> 0))
          (setf (f 3 1) (,<t> 0))
          (setf (f 3 2) (,<t> 0))
          (setf (f 3 3) (,<t> 1))
          x)))))

(define-template minv <s> <t> (x m)
  (let ((type (type-instance 'mat-type <s> <t>)))
    `((declare (type ,(lisp-type type) m x)
               (return-type ,(lisp-type type)))
      (let ((ma ,(place-form type 'arr 'm))
            (xa ,(place-form type 'arr 'x))
            (det (/ (,(compose-name #\/ 'mdet <s> <t>) m))))
        (macrolet ((e (y x) `(aref ma (+ ,x (* ,y ,',<s>))))
                   (f (&rest args)
                     (let ((gens (loop for i from 0 below (length args) collect (gensym (princ-to-string i)))))
                       `(let (,@(loop for arg in args for gen in gens collect (list gen arg)))
                          ,@(loop for g in gens
                                  for i from 0
                                  collect `(setf (aref xa ,i) ,g))
                          x))))
          ,(case <s>
             ;; FIXME: This *sucks*. Can't we compute this expansion?
             (2 `(f (* det (+ (e 1 1)))
                    (* det (- (e 0 1)))
                    (* det (- (e 1 0)))
                    (* det (+ (e 0 0)))))
             (3 `(f (* det (- (* (e 1 1) (e 2 2)) (* (e 1 2) (e 2 1))))
                    (* det (- (* (e 0 2) (e 2 1)) (* (e 0 1) (e 2 2))))
                    (* det (- (* (e 0 1) (e 1 2)) (* (e 0 2) (e 1 1))))
                    (* det (- (* (e 1 2) (e 2 0)) (* (e 1 0) (e 2 2))))
                    (* det (- (* (e 0 0) (e 2 2)) (* (e 0 2) (e 2 0))))
                    (* det (- (* (e 0 2) (e 1 0)) (* (e 0 0) (e 1 2))))
                    (* det (- (* (e 1 0) (e 2 1)) (* (e 1 1) (e 2 0))))
                    (* det (- (* (e 0 1) (e 2 0)) (* (e 0 0) (e 2 1))))
                    (* det (- (* (e 0 0) (e 1 1)) (* (e 0 1) (e 1 0))))))
             (4 `(f (* det (- (+ (* (e 1 2) (e 2 3) (e 3 1)) (* (e 1 3) (e 2 1) (e 3 2)) (* (e 1 1) (e 2 2) (e 3 3)))
                              (+ (* (e 1 3) (e 2 2) (e 3 1)) (* (e 1 1) (e 2 3) (e 3 2)) (* (e 1 2) (e 2 1) (e 3 3)))))
                    (* det (- (+ (* (e 0 3) (e 2 2) (e 3 1)) (* (e 0 1) (e 2 3) (e 3 2)) (* (e 0 2) (e 2 1) (e 3 3)))
                              (+ (* (e 0 2) (e 2 3) (e 3 1)) (* (e 0 3) (e 2 1) (e 3 2)) (* (e 0 1) (e 2 2) (e 3 3)))))
                    (* det (- (+ (* (e 0 2) (e 1 3) (e 3 1)) (* (e 0 3) (e 1 1) (e 3 2)) (* (e 0 1) (e 1 2) (e 3 3)))
                              (+ (* (e 0 3) (e 1 2) (e 3 1)) (* (e 0 1) (e 1 3) (e 3 2)) (* (e 0 2) (e 1 1) (e 3 3)))))
                    (* det (- (+ (* (e 0 3) (e 1 2) (e 2 1)) (* (e 0 1) (e 1 3) (e 2 2)) (* (e 0 2) (e 1 1) (e 2 3)))
                              (+ (* (e 0 2) (e 1 3) (e 2 1)) (* (e 0 3) (e 1 1) (e 2 2)) (* (e 0 1) (e 1 2) (e 2 3)))))
                    (* det (- (+ (* (e 1 3) (e 2 2) (e 3 0)) (* (e 1 0) (e 2 3) (e 3 2)) (* (e 1 2) (e 2 0) (e 3 3)))
                              (+ (* (e 1 2) (e 2 3) (e 3 0)) (* (e 1 3) (e 2 0) (e 3 2)) (* (e 1 0) (e 2 2) (e 3 3)))))
                    (* det (- (+ (* (e 0 2) (e 2 3) (e 3 0)) (* (e 0 3) (e 2 0) (e 3 2)) (* (e 0 0) (e 2 2) (e 3 3)))
                              (+ (* (e 0 3) (e 2 2) (e 3 0)) (* (e 0 0) (e 2 3) (e 3 2)) (* (e 0 2) (e 2 0) (e 3 3)))))
                    (* det (- (+ (* (e 0 3) (e 1 2) (e 3 0)) (* (e 0 0) (e 1 3) (e 3 2)) (* (e 0 2) (e 1 0) (e 3 3)))
                              (+ (* (e 0 2) (e 1 3) (e 3 0)) (* (e 0 3) (e 1 0) (e 3 2)) (* (e 0 0) (e 1 2) (e 3 3)))))
                    (* det (- (+ (* (e 0 2) (e 1 3) (e 2 0)) (* (e 0 3) (e 1 0) (e 2 2)) (* (e 0 0) (e 1 2) (e 2 3)))
                              (+ (* (e 0 3) (e 1 2) (e 2 0)) (* (e 0 0) (e 1 3) (e 2 2)) (* (e 0 2) (e 1 0) (e 2 3)))))
                    (* det (- (+ (* (e 1 1) (e 2 3) (e 3 0)) (* (e 1 3) (e 2 0) (e 3 1)) (* (e 1 0) (e 2 1) (e 3 3)))
                              (+ (* (e 1 3) (e 2 1) (e 3 0)) (* (e 1 0) (e 2 3) (e 3 1)) (* (e 1 1) (e 2 0) (e 3 3)))))
                    (* det (- (+ (* (e 0 3) (e 2 1) (e 3 0)) (* (e 0 0) (e 2 3) (e 3 1)) (* (e 0 1) (e 2 0) (e 3 3)))
                              (+ (* (e 0 1) (e 2 3) (e 3 0)) (* (e 0 3) (e 2 0) (e 3 1)) (* (e 0 0) (e 2 1) (e 3 3)))))
                    (* det (- (+ (* (e 0 1) (e 1 3) (e 3 0)) (* (e 0 3) (e 1 0) (e 3 1)) (* (e 0 0) (e 1 1) (e 3 3)))
                              (+ (* (e 0 3) (e 1 1) (e 3 0)) (* (e 0 0) (e 1 3) (e 3 1)) (* (e 0 1) (e 1 0) (e 3 3)))))
                    (* det (- (+ (* (e 0 3) (e 1 1) (e 2 0)) (* (e 0 0) (e 1 3) (e 2 1)) (* (e 0 1) (e 1 0) (e 2 3)))
                              (+ (* (e 0 1) (e 1 3) (e 2 0)) (* (e 0 3) (e 1 0) (e 2 1)) (* (e 0 0) (e 1 1) (e 2 3)))))
                    (* det (- (+ (* (e 1 2) (e 2 1) (e 3 0)) (* (e 1 0) (e 2 2) (e 3 1)) (* (e 1 1) (e 2 0) (e 3 2)))
                              (+ (* (e 1 1) (e 2 2) (e 3 0)) (* (e 1 2) (e 2 0) (e 3 1)) (* (e 1 0) (e 2 1) (e 3 2)))))
                    (* det (- (+ (* (e 0 1) (e 2 2) (e 3 0)) (* (e 0 2) (e 2 0) (e 3 1)) (* (e 0 0) (e 2 1) (e 3 2)))
                              (+ (* (e 0 2) (e 2 1) (e 3 0)) (* (e 0 0) (e 2 2) (e 3 1)) (* (e 0 1) (e 2 0) (e 3 2)))))
                    (* det (- (+ (* (e 0 2) (e 1 1) (e 3 0)) (* (e 0 0) (e 1 2) (e 3 1)) (* (e 0 1) (e 1 0) (e 3 2)))
                              (+ (* (e 0 1) (e 1 2) (e 3 0)) (* (e 0 2) (e 1 0) (e 3 1)) (* (e 0 0) (e 1 1) (e 3 2)))))
                    (* det (- (+ (* (e 0 1) (e 1 2) (e 2 0)) (* (e 0 2) (e 1 0) (e 2 1)) (* (e 0 0) (e 1 1) (e 2 2)))
                              (+ (* (e 0 2) (e 1 1) (e 2 0)) (* (e 0 0) (e 1 2) (e 2 1)) (* (e 0 1) (e 1 0) (e 2 2)))))))
             (T
              `(,(compose-name #\/ 'smatop '* '<t> <s> <t>)
                x (,(compose-name #\/ 'mcof <s> <t>) x m) det))))))))

(define-template mtransfer <sx> <s> <t> (x m xy xx w h my mx)
  (let ((type (type-instance 'mat-type <s> <t>))
        (rett (type-instance 'mat-type <sx> <t>)))
    `((declare (type ,(lisp-type type) m)
               (type ,(lisp-type rett) x)
               (type mat-dim xy xx w h my mx)
               (return-type ,(lisp-type rett))
               inline)
      (let* ((ma ,(place-form type 'arr 'm))
             (xa ,(place-form rett 'arr 'x))
             (mc ,(attribute type :cols 'm))
             (xc ,(attribute rett :cols 'x))
             (xi (+ xx (* xc xy)))
             (mi (+ mx (* mc my))))
        (declare (type mat-dim xi mi mc xc))
        (dotimes (_ h x)
          (dotimes (i w)
            (setf (aref xa (+ xi i)) (aref ma (+ mi i))))
          (setf xi (+ xi xc))
          (setf mi (+ mi mc)))))))

(define-template mswap-row <s> <t> (x m r1 r2)
  (let ((type (type-instance 'mat-type <s> <t>)))
    `((declare (type ,(lisp-type type) x m)
               (type dimension r1 r2)
               (return-type ,(lisp-type type))
               inline)
      (let* ((ma ,(place-form type 'arr 'm))
             (xa ,(place-form type 'arr 'x))
             (c ,(attribute type :cols 'm))
             (r1 (* c r1))
             (r2 (* c r2)))
        (unless (eq ma xa)
          (replace xa ma))
        (do-times (i 0 c 1 x)
          (rotatef (aref xa (+ r1 i)) (aref xa (+ r2 i))))))))

(define-template mswap-col <s> <t> (x m c1 c2)
  (let ((type (type-instance 'mat-type <s> <t>)))
    `((declare (type ,(lisp-type type) x m)
               (type dimension c1 c2)
               (return-type ,(lisp-type type))
               inline)
      (let* ((ma ,(place-form type 'arr 'm))
             (xa ,(place-form type 'arr 'x))
             (r ,(attribute type :rows 'm))
             (c ,(attribute type :cols 'm)))
        (unless (eq ma xa)
          (replace xa ma))
        (do-times (i 0 r 1 x)
          (rotatef (aref xa c1)
                   (aref xa c2))
          (incf c1 c)
          (incf c2 c))))))

(define-template mtranslate <s> <t> (x v)
  (when (member <s> '(2 n)) (template-unfulfillable))
  (let ((type (type-instance 'mat-type <s> <t>))
        (vtype (type-instance 'vec-type (1- <s>) <t>)))
    `((declare (type ,(lisp-type type) x)
               (type ,(lisp-type vtype) v)
               (return-type ,(lisp-type type))
               inline)
      (let ((va ,(place-form vtype 'arr 'v))
            (xa ,(place-form type 'arr 'x)))
        (macrolet ((e (x) `(aref va ,x))
                   (f (y x) `(aref xa (+ ,x (* ,y ,,(attribute type :cols 'x))))))
          ,@(loop for i from 0 below <s>
                  collect `(setf (f ,i ,(1- <s>))
                                 (,<t> (+ ,@(loop for j from 0 below <s>
                                                  collect `(* (f ,i ,j) ,(if (< j (1- <s>)) `(e ,j) 1)))))))
          x)))))

(define-template mscale <s> <t> (x v)
  (when (member <s> '(2 n)) (template-unfulfillable))
  (let ((type (type-instance 'mat-type <s> <t>))
        (vtype (type-instance 'vec-type (1- <s>) <t>)))
    `((declare (type ,(lisp-type type) x)
               (type ,(lisp-type vtype) v)
               (return-type ,(lisp-type type))
               inline)
      (let ((va ,(place-form vtype 'arr 'v))
            (xa ,(place-form type 'arr 'x)))
        (macrolet ((e (x) `(aref va ,x))
                   (f (y x) `(aref xa (+ ,x (* ,y ,,(attribute type :cols 'x))))))
          ,@(loop for i from 0 below <s>
                  append (loop for j from 0 below (1- <s>)
                               collect `(setf (f ,i ,j) (,<t> (* (f ,i ,j) (e ,j))))))
          x)))))

(define-template mrotate <s> <t> (x v angle)
  (when (member <t> '(i32 u32)) (template-unfulfillable))
  (when (member <s> '(2 n)) (template-unfulfillable))
  (let ((type (type-instance 'mat-type <s> <t>))
        (vtype (type-instance 'vec-type (1- <s>) <t>)))
    `((declare (type ,(lisp-type type) x)
               (type ,(lisp-type vtype) v)
               (type ,<t> angle)
               (return-type ,(lisp-type type))
               inline)
      (let ((va ,(place-form vtype 'arr 'v))
            (xa ,(place-form type 'arr 'x)))
        (macrolet ((e (x) `(aref va ,x))
                   (f (y x) `(aref xa (+ ,x (* ,y ,,(attribute type :cols 'x))))))
          ;; FIXME: implement
          x)))))

(defmacro define-generation-template (name args &body body)
  `(define-template ,name <s> <t> ,args
     (let ((type (type-instance 'mat-type <s> <t>)))
       (flet ((f (&rest args)
                (loop for arg in args
                      for i from 0 for x = (mod i 4) for y = (floor i 4)
                      when (and (< x <s>) (< y <s>))
                      collect `(setf (aref xa ,i) (,<t> ,arg)))))
         `((declare (type ,(lisp-type type) x)
                    (return-type ,(lisp-type type)))
           (let ((xa ,(place-form type 'arr 'x)))
             ,@(progn ,@body))
           x)))))

(define-generation-template mtranslation (x v)
  (when (member <s> '(2 n)) (template-unfulfillable))
  (let ((vtype (type-instance 'vec-type (case <s> (4 3) (3 2)) <t>)))
    `((declare (type ,(lisp-type vtype) v))
      ,@(case <s>
          (3 (f 1 0 (place-form vtype :x 'v)
                0 1 (place-form vtype :y 'v)
                0 0 1))
          (4 (f 1 0 0 (place-form vtype :x 'v)
                0 1 0 (place-form vtype :y 'v)
                0 0 1 (place-form vtype :z 'v)
                0 0 0 1))))))

(define-generation-template mscaling (x v)
  (when (member <s> '(n)) (template-unfulfillable))
  (let ((vtype (type-instance 'vec-type (case <s> (4 3) ((3 2) 2)) <t>)))
    `((declare (type ,(lisp-type vtype) v))
      ,@(case <s>
          (2 (f (place-form vtype :x 'v) 0
                0 (place-form vtype :y 'v)))
          (3 (f (place-form vtype :x 'v) 0 0
                0 (place-form vtype :y 'v) 0
                0 0 1))
          (4 (f (place-form vtype :x 'v) 0 0 0
                0 (place-form vtype :y 'v) 0 0
                0 0 (place-form vtype :z 'v) 0
                0 0 0 1))
          (T (template-unfulfillable))))))

(define-generation-template mrotation (x v angle)
  (when (member <s> '(n)) (template-unfulfillable))
  (when (member <t> '(i32 u32)) (template-unfulfillable))
  (let ((vtype (type-instance 'vec-type 3 <t>)))
    `((declare (type ,(lisp-type vtype) v)
               (type ,<t> angle))
      (let ((c (,<t> (cos angle)))
            (s (,<t> (sin angle))))
        ,@(case <s>
            (2 (f 'c '(- s)
                  's 'c))
            (T `((cond ((v= +vx3+ v)
                        ,@(f 1 0 0 0
                             0 'c '(- s) 0
                             0 's 'c 0
                             0 0 0 1))
                       ((v= +vy3+ v)
                        ,@(f 'c 0 's 0
                             0 1 0 0
                             '(- s) 0 'c 0
                             0 0 0 1))
                       ((v= +vz3+ v)
                        ,@(f 'c '(- s) 0 0
                             's 'c 0 0
                             0 0 1 0
                             0 0 0 1))
                       (T
                        ;; https://joombig.com/sqlc/3D-Rotation-Algorithm-about-arbitrary-axis-with-CC-code-tutorials-advance
                        (let* ((x ,(place-form vtype :x 'v))
                               (y ,(place-form vtype :y 'v))
                               (z ,(place-form vtype :z 'v))
                               (1-c (- 1 c))
                               (u2 (expt x 2))
                               (v2 (expt y 2))
                               (w2 (expt z 2))
                               (l (+ u2 v2 w2))
                               (sqrtl (sqrt l)))
                          ,@(f '(/ (+ u2 (* (+ v2 w2) c)) l)        '(/ (- (* x y 1-c) (* z sqrtl s)) l) '(/ (+ (* x z 1-c) (* y sqrtl s)) l) 0
                               '(/ (+ (* x y 1-c) (* z sqrtl s)) l) '(/ (+ v2 (* (+ u2 w2) c)) l)        '(/ (- (* y z 1-c) (* x sqrtl s)) l) 0
                               '(/ (- (* x z 1-c) (* y sqrtl s)) l) '(/ (+ (* y z 1-c) (* x sqrtl s)) l) '(/ (+ w2 (* (+ u2 v2) c)) l)        0
                               0                                   0                                   0                                   1)))))))))))

(define-generation-template mlookat (x eye target up)
  (unless (eql <s> 4) (template-unfulfillable))
  (when (member <t> '(i32 u32)) (template-unfulfillable))
  (let ((vtype (type-instance 'vec-type 3 <t>)))
    `((declare (type ,(lisp-type vtype) eye target up))
      (let* ((z (nvunit (v- eye target)))
             (x (nvunit (vc up z)))
             (y (vc z x)))
        ,@(f (place-form vtype :x 'x) (place-form vtype :y 'x) (place-form vtype :z 'x) '(- (v. x eye))
             (place-form vtype :x 'y) (place-form vtype :y 'y) (place-form vtype :z 'y) '(- (v. y eye))
             (place-form vtype :x 'z) (place-form vtype :y 'z) (place-form vtype :z 'z) '(- (v. z eye))
             0 0 1)))))

(define-generation-template mfrustum (x l r b u n f)
  (unless (eql <s> 4) (template-unfulfillable))
  (when (member <t> '(i32 u32)) (template-unfulfillable))
  `((declare (type ,<t> l r b u n f))
    ,@(f '(/ (* 2 n) (- r l)) 0                    '(/ (+ r l) (- r l))     0
         0                    '(/ (* 2 n) (- u b)) '(/ (+ u b) (- u b))     0
         0                    0                    '(- (/ (+ f n) (- f n))) '(/ (* -2 f n) (- f n))
         0                    0                    -1                       0)))

(define-template mperspective <s> <t> (x fovy aspect near far)
  (unless (eql <s> 4) (template-unfulfillable))
  (when (member <t> '(i32 u32)) (template-unfulfillable))
  (let ((type (type-instance 'mat-type <s> <t>)))
    `((declare (type ,(lisp-type type) x)
               (type ,<t> fovy aspect near far)
               (return-type ,(lisp-type type))
               inline)
      (let* ((fh (* (the ,<t> (tan (* (/ fovy (,<t> 360)) (,<t> PI)))) near))
             (fw (* fh aspect)))
        (,(compose-name #\/ 'mfrustum <s> <t>) x (- fw) fw (- fh) fh near far)))))

(define-generation-template mortho (x l r b u n f)
  (unless (eql <s> 4) (template-unfulfillable))
  (when (member <t> '(i32 u32)) (template-unfulfillable))
  `((declare (type ,<t> l r b u n f))
    ,@(f '(/ 2 (- r l)) 0              0              '(- (/ (+ r l) (- r l)))
         0              '(/ 2 (- u b)) 0              '(- (/ (+ u b) (- u b)))
         0              0             '(/ -2 (- f n)) '(- (/ (+ f n) (- f n)))
         0              0              0              1)))

(define-template m1norm <s> <t> (m)
  (let ((type (type-instance 'mat-type <s> <t>)))
    `((declare (type ,(lisp-type type) m)
               (return-type ,<t>)
               inline)
      (let ((ma ,(place-form type 'arr 'm))
            (mc ,(attribute type :cols))
            (max (,<t> 0)))
        (do-times (x 0 ,(attribute type :cols) 1 max)
          (let ((col (,<t> 0)))
            (do-times (y 0 ,(attribute type :rows) 1)
              (setf col (+ col (abs (aref ma (+ x (* y mc)))))))
            (when (< max col)
              (setf max col))))))))

(define-template minorm <s> <t> (m)
  (let ((type (type-instance 'mat-type <s> <t>)))
    `((declare (type ,(lisp-type type) m)
               (return-type ,<t>)
               inline)
      (let ((ma ,(place-form type 'arr 'm))
            (mc ,(attribute type :cols))
            (max (,<t> 0)))
        (do-times (y 0 ,(attribute type :rows) 1 max)
          (let ((col (,<t> 0)))
            (do-times (x 0 ,(attribute type :cols) 1)
              (setf col (+ col (abs (aref ma (+ x (* y mc)))))))
            (when (< max col)
              (setf max col))))))))

(define-template m2norm <s> <t> (m)
  (let ((type (type-instance 'mat-type <s> <t>)))
    `((declare (type ,(lisp-type type) m)
               (return-type ,<t>)
               inline)
      (let ((ma ,(place-form type 'arr 'm))
            (sum (,<t> 0)))
        (do-times (i 0 ,(attribute type :len) 1 sum)
          (setf sum (+ sum (expt (aref ma i) 2))))))))

(define-template mtrace <s> <t> (m)
  (let ((type (type-instance 'mat-type <s> <t>)))
    `((declare (type ,(lisp-type type) m)
               (return-type ,<t>)
               inline)
      (let* ((ma ,(place-form type 'arr 'm))
             (mc ,(attribute type :cols))
             (ret (,<t> 0))
             (mi 0))
        (dotimes (i (min ,(attribute type :cols) ,(attribute type :rows)) ret)
          (setf ret (+ ret (aref ma mi)))
          (incf mi (1+ mc)))))))

(define-template mdiag <s> <t> (r m)
  (let ((type (type-instance 'mat-type <s> <t>)))
    `((declare (type ,(lisp-type type) m)
               (type (simple-array ,<t> (*)) r)
               (return-type (simple-array ,<t> (*)))
               inline)
      (let* ((ma ,(place-form type 'arr 'm))
             (mc ,(attribute type :cols))
             (mi 0))
        (do-times (i 0 (min ,(attribute type :rows) ,(attribute type :cols)) 1 r)
          (setf (aref r i) (aref ma mi))
          (incf mi (1+ mc)))))))

(define-template mrow <s> <t> (r m ri)
  (let ((type (type-instance 'mat-type <s> <t>)))
    `((declare (type ,(lisp-type type) m)
               (type (simple-array ,<t> (*)) r)
               (type dimension ri)
               (return-type (simple-array ,<t> (*)))
               inline)
      (let* ((ma ,(place-form type 'arr 'm))
             (cs ,(attribute type :cols 'm))
             (ri (* cs ri)))
        (do-times (i 0 cs 1 r)
          (setf (aref r i) (aref ma (+ ri i))))))))

(define-template mcol <s> <t> (c m ci)
  (let ((type (type-instance 'mat-type <s> <t>)))
    `((declare (type ,(lisp-type type) m)
               (type (simple-array ,<t> (*)) c)
               (type dimension ci)
               (return-type (simple-array ,<t> (*)))
               inline)
      (let* ((ma ,(place-form type 'arr 'm))
             (cs ,(attribute type :cols 'm))
             (rs ,(attribute type :rows 'm)))
        (do-times (i 0 rs 1 c)
          (setf (aref c i) (aref ma ci))
          (incf ci cs))))))

(do-mat-combinations define-mapply)
(do-mat-combinations define-mvec)
(do-mat-combinations define-copy)
(do-mat-combinations define-smatop (+ - * / min max) (<t> real))
(do-mat-combinations define-1matop (- / identity))
(do-mat-combinations define-2matreduce (and) (= ~= /= < <= >= >) boolean)
(do-mat-combinations define-smatreduce (and) (= ~= /= < <= >= >) (<t> real) boolean)
(do-mat-combinations define-2matreduce (or) (/=) boolean)
(do-mat-combinations define-smatreduce (or) (/=) (<t> real) boolean)
(do-mat-combinations define-0matop (zero eye rand))
(do-mat-combinations define-m*m)
(do-mat-combinations define-m*v (2 3 4))
(do-mat-combinations define-mdet)
(do-mat-combinations define-minv)
(do-mat-combinations define-mminor)
(do-mat-combinations define-minv-affine)
(do-mat-combinations define-mcof)
(do-mat-combinations define-mtranspose)
(do-mat-combinations define-mtrace)
(do-mat-combinations define-mtransfer (2 3 4 n))
(do-mat-combinations define-mswap-row)
(do-mat-combinations define-mswap-col)
(do-mat-combinations define-mtranslate)
(do-mat-combinations define-mscale)
(do-mat-combinations define-mrotate)
(do-mat-combinations define-mtranslation)
(do-mat-combinations define-mscaling)
(do-mat-combinations define-mrotation)
(do-mat-combinations define-mlookat)
(do-mat-combinations define-mfrustum)
(do-mat-combinations define-mperspective)
(do-mat-combinations define-mortho)
(do-mat-combinations define-m1norm)
(do-mat-combinations define-minorm)
(do-mat-combinations define-m2norm)
(do-mat-combinations define-mdiag)
(do-mat-combinations define-mrow)
(do-mat-combinations define-mcol)
