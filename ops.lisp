#|
 This file is a part of 3d-matrices
 (c) 2016 Shirakumo http://tymoon.eu (shinmera@tymoon.eu)
 Author: Nicolas Hafner <shinmera@tymoon.eu>
|#

(in-package #:org.shirakumo.flare.matrix)

;; So as to not reach inline expansion limits.
(defmacro %c2 (y x) `(aref (%marr2 m) ,(+ x (* y 2))))
(defmacro %c3 (y x) `(aref (%marr3 m) ,(+ x (* y 3))))
(defmacro %c4 (y x) `(aref (%marr4 m) ,(+ x (* y 4))))

(defmacro with-fast-matref ((accessor mat width) &body body)
  (let ((w (gensym "WIDTH")) (arr (gensym "ARRAY")))
    `(let ((,w ,width)
           (,arr (,(case width (2 '%marr2) (3 '%marr3) (4 '%marr4) (T 'marr)) ,mat)))
       (declare (ignorable ,w))
       (macrolet ((,accessor (y &optional x) `(aref ,',arr ,(if x
                                                                `(+ ,x (* ,y ,',(if (constantp width) width w)))
                                                                y))))
         ,@body))))

(defmacro with-fast-matrefs (bindings &body body)
  (if bindings
      `(with-fast-matref ,(first bindings)
         (with-fast-matrefs ,(rest bindings)
           ,@body))
      `(progn ,@body)))

(defmacro with-fast-matcase ((accessor mat) &body body)
  (let ((mat2 (cdr (assoc 'mat2 body)))
        (mat3 (cdr (assoc 'mat3 body)))
        (mat4 (cdr (assoc 'mat4 body)))
        (matn (cdr (assoc 'matn body))))
    `(etypecase ,mat
       ,@(when mat2
           `((mat2 (with-fast-matref (,accessor ,mat 2)
                     ,@mat2))))
       ,@(when mat3
           `((mat3 (with-fast-matref (,accessor ,mat 3)
                     ,@mat3))))
       ,@(when mat4
           `((mat4 (with-fast-matref (,accessor ,mat 4)
                     ,@mat4))))
       ,@(when matn
           `((matn ,@matn))))))

(define-ofun midentity (n)
  (case n
    (2 (mat2 '(1 0
               0 1)))
    (3 (mat3 '(1 0 0
               0 1 0
               0 0 1)))
    (4 (mat4 '(1 0 0 0
               0 1 0 0
               0 0 1 0
               0 0 0 1)))
    (T (let ((mat (matn n n)))
         (do-mat-diag (i e mat mat)
           (setf e 1))))))

(declaim (ftype (function (mat mat-dim) vec) mcol))
(define-ofun mcol (mat n)
  (with-fast-matcase (e mat)
    (mat2 (vec2 (e 0 n) (e 1 n)))
    (mat3 (vec3 (e 0 n) (e 1 n) (e 2 n)))
    (mat4 (vec4 (e 0 n) (e 1 n) (e 2 n) (e 3 n)))))

(declaim (ftype (function (vec mat mat-dim) vec) (setf mcol)))
(define-ofun (setf mcol) (vec mat n)
  (with-fast-matcase (e mat)
    (mat2 (setf (e 0 n) (vx vec) (e 1 n) (vy vec)))
    (mat3 (setf (e 0 n) (vx vec) (e 1 n) (vy vec) (e 2 n) (vz vec)))
    (mat4 (setf (e 0 n) (vx vec) (e 1 n) (vy vec) (e 2 n) (vz vec) (e 3 n) (vw vec))))
  vec)

(declaim (ftype (function (mat mat-dim) vec) mrow))
(defun mrow (mat n)
  (with-fast-matcase (e mat)
    (mat2 (vec2 (e n 0) (e n 1)))
    (mat3 (vec3 (e n 0) (e n 1) (e n 2)))
    (mat4 (vec4 (e n 0) (e n 1) (e n 2) (e n 3)))))

(declaim (ftype (function (vec mat mat-dim) vec) (setf mrow)))
(defun (setf mrow) (vec mat n)
  (with-fast-matcase (e mat)
    (mat2 (setf (e n 0) (vx vec) (e n 1) (vy vec)))
    (mat3 (setf (e n 0) (vx vec) (e n 1) (vy vec) (e n 2) (vz vec)))
    (mat4 (setf (e n 0) (vx vec) (e n 1) (vy vec) (e n 2) (vz vec) (e n 3) (vw vec))))
  vec)

(defmacro %2mat-op (a b c m2 m3 m4 mnmn mnr)
  (let ((m2 (if (listp m2) m2 (list m2)))
        (m3 (if (listp m3) m3 (list m3)))
        (m4 (if (listp m4) m4 (list m4)))
        (e (gensym "E")) (f (gensym "F")))
    (flet ((unroll (size &optional constant)
             (loop for i from 0 below size
                   collect `(,c (,e ,i) ,(if constant b `(,f ,i))))))
      `(if (realp ,a)
           (let ((,b (ensure-float ,a))
                 (,a ,b))
             (with-fast-matcase (,e ,a)
               (mat4 (,@m4 ,@(unroll 16 T)))
               (mat3 (,@m3 ,@(unroll 9 T)))
               (mat2 (,@m2 ,@(unroll 4 T)))
               (matn ,mnr)))
           (with-fast-matcase (,e ,a)
             (mat4 (etypecase ,b
                     (real (let ((,b (ensure-float ,b))) (,@m4 ,@(unroll 16 T))))
                     (mat4 (with-fast-matref (,f ,b 4) (,@m4 ,@(unroll 16))))))
             (mat3 (etypecase ,b
                     (real (let ((,b (ensure-float ,b))) (,@m4 ,@(unroll 9 T))))
                     (mat3 (with-fast-matref (,f ,b 3) (,@m3 ,@(unroll 9))))))
             (mat2 (etypecase ,b
                     (real (let ((,b (ensure-float ,b))) (,@m4 ,@(unroll 4 T))))
                     (mat2 (with-fast-matref (,f ,b 2) (,@m2 ,@(unroll 4))))))
             (matn (etypecase ,b
                     (real (let ((,b (ensure-float ,b)))
                             ,mnr))
                     (mat
                      (assert (and (= (mcols a) (mcols b))
                                   (= (mrows a) (mrows b))))
                      ,mnmn))))))))

(defmacro define-matcomp (name op)
  (let ((2mat-name (intern (format NIL "~a-~a" '2mat name))))
    `(progn
       (declaim (inline ,2mat-name))
       (declaim (ftype (function ((or mat real) (or mat real)) boolean) ,2mat-name))
       (declaim (ftype (function ((or mat real) &rest (or mat real)) boolean) ,name))
       (define-ofun ,2mat-name (a b)
         (%2mat-op a b ,op and and and
                   (with-fast-matrefs ((e a (%cols a))
                                       (f b (%cols b)))
                     (loop for i from 0 below (* (%cols a) (%rows a))
                           always (,op (e i) (f i))))
                   (with-fast-matref (e a (%cols a))
                     (loop for i from 0 below (* (%cols a) (%rows a))
                           always (,op (e i) b)))))
       (define-ofun ,name (val &rest vals)
         (loop for prev = val then next
               for next in vals
               always (,2mat-name prev next)))
       (define-compiler-macro ,name (val &rest vals)
         (case (length vals)
           (0 T)
           (1 `(,',2mat-name ,val ,(first vals)))
           (T `(and ,@(loop for prev = val then next
                            for next in vals
                            collect `(,',2mat-name ,prev ,next)))))))))

(define-matcomp m= =)
(define-matcomp m/= /=)
(define-matcomp m< <)
(define-matcomp m> >)
(define-matcomp m<= <=)
(define-matcomp m>= >=)

(defmacro define-matop (name nname op)
  (let ((2mat-name (intern (format NIL "~a-~a" '2mat name))))
    `(progn
       (declaim (inline ,name ,2mat-name))
       (declaim (ftype (function ((or mat real) &rest (or mat real)) mat) ,name))
       (declaim (ftype (function ((or mat real) (or mat real)) mat) ,2mat-name))
       (define-ofun ,2mat-name (a b)
         (%2mat-op a b ,op mat mat mat
                   (let ((mat (matn (%rows a) (%cols a))))
                     (with-fast-matrefs ((e a (%cols a))
                                         (f b (%cols b))
                                         (g mat (%cols a)))
                       (dotimes (i (* (%cols mat) (%rows mat)) mat)
                         (setf (g i) (,op (e i) (f i))))))
                   (let ((mat (matn (%rows a) (%cols a))))
                     (with-fast-matrefs ((e a (%cols a))
                                         (g mat (%cols a)))
                       (dotimes (i (* (%cols mat) (%rows mat)) mat)
                         (setf (g i) (,op (e i) b)))))))
       (define-ofun ,name (val &rest vals)
         (cond ((cdr vals)
                (apply #',nname (,2mat-name val (first vals)) (rest vals)))
               (vals (,2mat-name val (first vals)))
               (T (mapply val #',op))))
       (define-compiler-macro ,name (val &rest vals)
         (case (length vals)
           (0 `(mapply ,val #',',op))
           (1 `(,',2mat-name ,val ,(first vals)))
           (T `(,',nname (,',2mat-name ,val ,(first val)) ,@(rest vals))))))))

(defmacro define-nmatop (name op)
  (let ((2mat-name (intern (format NIL "~a-~a" '2mat name))))
    `(progn
       (declaim (inline ,name ,2mat-name))
       (declaim (ftype (function ((or mat real) &rest (or mat real)) mat) ,name))
       (declaim (ftype (function ((or mat real) (or mat real)) mat) ,2mat-name))
       (define-ofun ,2mat-name (a b)
         (%2mat-op a b ,op mat mat mat
                   (with-fast-matrefs ((e a (%cols a))
                                       (f b (%cols b)))
                     (dotimes (i (* (%cols a) (%rows a)) a)
                       (setf (e i) (,op (e i) (f i)))))
                   (with-fast-matref (e a (%cols a))
                     (dotimes (i (* (%cols a) (%rows a)) a)
                       (setf (e i) (,op (e i) b))))))
       (define-ofun ,name (val &rest vals)
         (if vals
             (loop for v in vals
                   do (,2mat-name val v)
                   finally (return val))
             (mapplyf val #',op)))
       (define-compiler-macro ,name (val &rest vals)
         (case (length vals)
           (0 `(mapplyf ,val #',',op))
           (1 `(,',2mat-name ,val ,(first vals)))
           (T `(,',name (,',2mat-name ,val ,(first val)) ,@(rest vals))))))))

(define-matop m+ nm+ +)
(define-matop m- nm- -)
(define-matop m* nm* *)
(define-matop m/ nm/ /)
(define-nmatop nm+ +)
(define-nmatop nm- -)
(define-nmatop nm* *)
(define-nmatop nm/ /)

(declaim (inline mapply))
(declaim (ftype (function (mat (or symbol function)) mat) mapply))
(define-ofun mapply (mat op)
  (etypecase mat
    (mat2 (let ((m (mat2))) (map-into (%marr2 m) op (%marr2 mat)) m))
    (mat3 (let ((m (mat3))) (map-into (%marr3 m) op (%marr3 mat)) m))
    (mat4 (let ((m (mat4))) (map-into (%marr4 m) op (%marr4 mat)) m))
    (matn (let ((m (matn (%rows mat) (%cols mat))))
            (map-into (%marrn m) op (%marrn mat))
            m))))

(declaim (inline mapplyf))
(declaim (ftype (function (mat (or symbol function)) mat) mapplyf))
(define-ofun mapplyf (mat op)
  (etypecase mat
    (mat2 (map-into (%marr2 mat) op (%marr2 mat)) mat)
    (mat3 (map-into (%marr3 mat) op (%marr3 mat)) mat)
    (mat4 (map-into (%marr4 mat) op (%marr4 mat)) mat)
    (matn (map-into (%marrn mat) op (%marrn mat)) mat)))

;; Lots of juicy inlined crap.
(declaim (ftype (function (mat) #.*float-type*) mdet))
(define-ofun mdet (m)
  (with-fast-matcase (e m)
    (mat2 (- (* (e 0 0) (e 1 1))
             (* (e 0 1) (e 1 0))))
    (mat3 (- (+ (* (e 0 0) (e 1 1) (e 2 2))
                (* (e 0 1) (e 1 2) (e 2 0))
                (* (e 0 2) (e 1 0) (e 2 1)))
             (+ (* (e 0 0) (e 1 2) (e 2 1))
                (* (e 0 1) (e 1 0) (e 2 2))
                (* (e 0 2) (e 1 1) (e 2 0)))))
    (mat4 (- (+ (* (e 0 3) (e 1 2) (e 2 1) (e 3 0)) (* (e 0 0) (e 1 1) (e 2 2) (e 3 3))
                (* (e 0 1) (e 1 3) (e 2 2) (e 3 0)) (* (e 0 2) (e 1 1) (e 2 3) (e 3 0))
                (* (e 0 2) (e 1 3) (e 2 0) (e 3 1)) (* (e 0 3) (e 1 0) (e 2 2) (e 3 1))
                (* (e 0 0) (e 1 2) (e 2 3) (e 3 1)) (* (e 0 3) (e 1 1) (e 2 0) (e 3 2))
                (* (e 0 0) (e 1 3) (e 2 1) (e 3 2)) (* (e 0 1) (e 1 0) (e 2 3) (e 3 2))
                (* (e 0 1) (e 1 2) (e 2 0) (e 3 3)) (* (e 0 2) (e 1 0) (e 2 1) (e 3 3)))
             (+ (* (e 0 2) (e 1 3) (e 2 1) (e 3 0)) (* (e 0 3) (e 1 1) (e 2 2) (e 3 0))
                (* (e 0 1) (e 1 2) (e 2 3) (e 3 0)) (* (e 0 3) (e 1 2) (e 2 0) (e 3 1))
                (* (e 0 0) (e 1 3) (e 2 2) (e 3 1)) (* (e 0 2) (e 1 0) (e 2 3) (e 3 1))
                (* (e 0 1) (e 1 3) (e 2 0) (e 3 2)) (* (e 0 3) (e 1 0) (e 2 1) (e 3 2))
                (* (e 0 0) (e 1 1) (e 2 3) (e 3 2)) (* (e 0 2) (e 1 1) (e 2 0) (e 3 3))
                (* (e 0 0) (e 1 2) (e 2 1) (e 3 3)) (* (e 0 1) (e 1 0) (e 2 2) (e 3 3)))))
    (matn (multiple-value-bind (LU P s) (mlu m)
            (declare (ignore P))
            (with-fast-matref (lu LU (%rows LU))
              (loop for det = #.(ensure-float 1) then (* (expt -1.0 (the integer s))
                                                         (the #.*float-type* det)
                                                         (lu i i))
                    for i from 0 below (%rows LU)
                    finally (return det)))))))

;; More of the same.
(declaim (ftype (function (mat) mat) minv))
(define-ofun minv (m)
  (let ((det (/ (mdet m))))
    (with-fast-matcase (e m)
      (mat2 (mat (* det (+ (e 1 1)))
                 (* det (- (e 0 1)))
                 (* det (- (e 1 0)))
                 (* det (+ (e 0 0)))))
      (mat3 (mat (* det (- (* (e 1 1) (e 2 2)) (* (e 1 2) (e 2 1))))
                 (* det (- (* (e 0 2) (e 2 1)) (* (e 0 1) (e 2 2))))
                 (* det (- (* (e 0 1) (e 1 2)) (* (e 0 2) (e 1 1))))
                 (* det (- (* (e 1 2) (e 2 0)) (* (e 1 0) (e 2 2))))
                 (* det (- (* (e 0 0) (e 2 2)) (* (e 0 2) (e 2 0))))
                 (* det (- (* (e 0 2) (e 1 0)) (* (e 0 0) (e 1 2))))
                 (* det (- (* (e 1 0) (e 2 1)) (* (e 1 1) (e 2 0))))
                 (* det (- (* (e 0 1) (e 2 0)) (* (e 0 0) (e 2 1))))
                 (* det (- (* (e 0 0) (e 1 1)) (* (e 0 1) (e 1 0))))))
      (mat4 (mat (* det (- (+ (* (e 1 2) (e 2 3) (e 3 1)) (* (e 1 3) (e 2 1) (e 3 2)) (* (e 1 1) (e 2 2) (e 3 3)))
                           (+ (* (e 1 3) (e 2 2) (e 3 1)) (* (e 1 1) (e 2 3) (e 3 2)) (* (e 1 2) (e 2 1) (e 3 3)))))
                 (* det (- (+ (* (e 0 3) (e 2 2) (e 3 1)) (* (e 0 1) (e 2 3) (e 3 2)) (* (e 0 2) (e 2 1) (e 3 3)))
                           (+ (* (e 0 2) (e 2 3) (e 3 1)) (* (e 0 3) (e 2 1) (e 3 2)) (* (e 0 1) (e 2 2) (e 3 3)))))
                 (* det (- (+ (* (e 0 2) (e 1 3) (e 3 1)) (* (e 0 3) (e 1 1) (e 3 2)) (* (e 0 1) (e 1 2) (e 3 3)))
                           (+ (* (e 0 3) (e 1 2) (e 3 1)) (* (e 0 1) (e 1 3) (e 3 2)) (* (e 0 2) (e 1 1) (e 3 3)))))
                 (* det (- (+ (* (e 0 3) (e 1 2) (e 2 1)) (* (e 0 1) (e 1 3) (e 2 2)) (* (e 0 2) (e 1 1) (e 2 3)))
                           (+ (* (e 0 2) (e 1 3) (e 2 1)) (* (e 0 3) (e 1 1) (e 2 2)) (* (e 0 1) (e 1 2) (e 2 3)))))
                 (* det (- (+ (* (e 1 3) (e 2 2) (e 3 0)) (* (e 1 0) (e 2 3) (e 3 2)) (* (e 1 2) (e 2 0) (e 3 3)))
                           (+ (* (e 1 2) (e 2 3) (e 3 0)) (* (e 1 3) (e 2 0) (e 3 2)) (* (e 1 0) (e 2 2) (e 3 3)))))
                 (* det (- (+ (* (e 0 2) (e 2 3) (e 3 0)) (* (e 0 3) (e 2 0) (e 3 2)) (* (e 0 0) (e 2 2) (e 3 3)))
                           (+ (* (e 0 3) (e 2 2) (e 3 0)) (* (e 0 0) (e 2 3) (e 3 2)) (* (e 0 2) (e 2 0) (e 3 3)))))
                 (* det (- (+ (* (e 0 3) (e 1 2) (e 3 0)) (* (e 0 0) (e 1 3) (e 3 2)) (* (e 0 2) (e 1 0) (e 3 3)))
                           (+ (* (e 0 2) (e 1 3) (e 3 0)) (* (e 0 3) (e 1 0) (e 3 2)) (* (e 0 0) (e 1 2) (e 3 3)))))
                 (* det (- (+ (* (e 0 2) (e 1 3) (e 2 0)) (* (e 0 3) (e 1 0) (e 2 2)) (* (e 0 0) (e 1 2) (e 2 3)))
                           (+ (* (e 0 3) (e 1 2) (e 2 0)) (* (e 0 0) (e 1 3) (e 2 2)) (* (e 0 2) (e 1 0) (e 2 3)))))
                 (* det (- (+ (* (e 1 1) (e 2 3) (e 3 0)) (* (e 1 3) (e 2 0) (e 3 1)) (* (e 1 0) (e 2 1) (e 3 3)))
                           (+ (* (e 1 3) (e 2 1) (e 3 0)) (* (e 1 0) (e 2 3) (e 3 1)) (* (e 1 1) (e 2 0) (e 3 3)))))
                 (* det (- (+ (* (e 0 3) (e 2 1) (e 3 0)) (* (e 0 0) (e 2 3) (e 3 1)) (* (e 0 1) (e 2 0) (e 3 3)))
                           (+ (* (e 0 1) (e 2 3) (e 3 0)) (* (e 0 3) (e 2 0) (e 3 1)) (* (e 0 0) (e 2 1) (e 3 3)))))
                 (* det (- (+ (* (e 0 1) (e 1 3) (e 3 0)) (* (e 0 3) (e 1 0) (e 3 1)) (* (e 0 0) (e 1 1) (e 3 3)))
                           (+ (* (e 0 3) (e 1 1) (e 3 0)) (* (e 0 0) (e 1 3) (e 3 1)) (* (e 0 1) (e 1 0) (e 3 3)))))
                 (* det (- (+ (* (e 0 3) (e 1 1) (e 2 0)) (* (e 0 0) (e 1 3) (e 2 1)) (* (e 0 1) (e 1 0) (e 2 3)))
                           (+ (* (e 0 1) (e 1 3) (e 2 0)) (* (e 0 3) (e 1 0) (e 2 1)) (* (e 0 0) (e 1 1) (e 2 3)))))
                 (* det (- (+ (* (e 1 2) (e 2 1) (e 3 0)) (* (e 1 0) (e 2 2) (e 3 1)) (* (e 1 1) (e 2 0) (e 3 2)))
                           (+ (* (e 1 1) (e 2 2) (e 3 0)) (* (e 1 2) (e 2 0) (e 3 1)) (* (e 1 0) (e 2 1) (e 3 2)))))
                 (* det (- (+ (* (e 0 1) (e 2 2) (e 3 0)) (* (e 0 2) (e 2 0) (e 3 1)) (* (e 0 0) (e 2 1) (e 3 2)))
                           (+ (* (e 0 2) (e 2 1) (e 3 0)) (* (e 0 0) (e 2 2) (e 3 1)) (* (e 0 1) (e 2 0) (e 3 2)))))
                 (* det (- (+ (* (e 0 2) (e 1 1) (e 3 0)) (* (e 0 0) (e 1 2) (e 3 1)) (* (e 0 1) (e 1 0) (e 3 2)))
                           (+ (* (e 0 1) (e 1 2) (e 3 0)) (* (e 0 2) (e 1 0) (e 3 1)) (* (e 0 0) (e 1 1) (e 3 2)))))
                 (* det (- (+ (* (e 0 1) (e 1 2) (e 2 0)) (* (e 0 2) (e 1 0) (e 2 1)) (* (e 0 0) (e 1 1) (e 2 2)))
                           (+ (* (e 0 2) (e 1 1) (e 2 0)) (* (e 0 0) (e 1 2) (e 2 1)) (* (e 0 1) (e 1 0) (e 2 2)))))))
      (matn (nm* (madj m) det)))))

(declaim (ftype (function (mat) mat) mtranspose))
(define-ofun mtranspose (m)
  (with-fast-matcase (e m)
    (mat2 (mat (e 0 0) (e 1 0)
               (e 0 1) (e 1 1)))
    (mat3 (mat (e 0 0) (e 1 0) (e 2 0)
               (e 0 1) (e 1 1) (e 2 1)
               (e 0 2) (e 1 2) (e 2 2)))
    (mat4 (mat (e 0 0) (e 1 0) (e 2 0) (e 3 0)
               (e 0 1) (e 1 1) (e 2 1) (e 3 1)
               (e 0 2) (e 1 2) (e 2 2) (e 3 2)
               (e 0 3) (e 1 3) (e 2 3) (e 3 3)))
    (matn (let ((r (matn (%rows m) (%cols m))))
            (dotimes (y (%rows m) r)
              (dotimes (x (%cols m))
                (setf (mcrefn r x y) (mcrefn m y x))))))))

(declaim (ftype (function (mat) #.*float-type*) mtrace))
(define-ofun mtrace (m)
  (with-fast-matcase (e m)
    (mat2 (+ (e 0 0) (e 1 1)))
    (mat3 (+ (e 0 0) (e 1 1) (e 2 2)))
    (mat4 (+ (e 0 0) (e 1 1) (e 2 2) (e 3 3)))
    (matn (let ((sum #.(ensure-float 0)))
            (do-mat-diag (i el m sum)
              (setf sum (+ el (the #.*float-type* sum))))))))

(declaim (ftype (function (mat mat-dim mat-dim) #.*float-type*) mcoefficient))
(defun mcoefficient (m y x)
  (error "COEFFICIENT CALCULATION NOT IMPLEMENTED YET. FIX IT, STUPID."))

(declaim (ftype (function (mat) mat) mcof))
(define-ofun mcof (m)
  (etypecase m
    (mat2 (mat (mcoefficient m 0 0) (mcoefficient m 0 1)
               (mcoefficient m 1 0) (mcoefficient m 1 1)))
    (mat3 (mat (mcoefficient m 0 0) (mcoefficient m 0 1) (mcoefficient m 0 2)
               (mcoefficient m 1 0) (mcoefficient m 1 1) (mcoefficient m 1 2)
               (mcoefficient m 2 0) (mcoefficient m 2 1) (mcoefficient m 2 2)))
    (mat4 (mat (mcoefficient m 0 0) (mcoefficient m 0 1) (mcoefficient m 0 2) (mcoefficient m 0 3)
               (mcoefficient m 1 0) (mcoefficient m 1 1) (mcoefficient m 1 2) (mcoefficient m 1 3)
               (mcoefficient m 2 0) (mcoefficient m 2 1) (mcoefficient m 2 2) (mcoefficient m 2 3)
               (mcoefficient m 3 0) (mcoefficient m 3 1) (mcoefficient m 3 2) (mcoefficient m 3 3)))
    (matn (let ((r (matn (%rows m) (%cols m))))
            (dotimes (y (%rows m) r)
              (dotimes (x (%cols m) r)
                (setf (mcrefn r y x) (mcoefficient m y x))))))))

(declaim (ftype (function (mat) mat) madj))
(define-ofun madj (m)
  (declare (inline mtranspose mcof))
  (with-fast-matcase (e m)
    (mat2 (mat (+ (e 1 1))
               (- (e 1 0))
               (- (e 0 1))
               (+ (e 0 0))))
    (mat3 (mat (- (* (e 1 1) (e 2 2))
                  (* (e 1 2) (e 2 1)))
               (- (* (e 0 2) (e 2 1))
                  (* (e 0 1) (e 2 2)))
               (- (* (e 0 1) (e 1 2))
                  (* (e 0 2) (e 1 1)))
               (- (* (e 1 2) (e 2 0))
                  (* (e 1 0) (e 2 2)))
               (- (* (e 0 0) (e 2 2))
                  (* (e 0 2) (e 2 0)))
               (- (* (e 0 2) (e 1 0))
                  (* (e 0 0) (e 1 2)))
               (- (* (e 1 0) (e 2 1))
                  (* (e 1 1) (e 2 0)))
               (- (* (e 0 1) (e 2 0))
                  (* (e 0 0) (e 2 1)))
               (- (* (e 0 0) (e 1 1))
                  (* (e 0 1) (e 1 0)))))
    (mat4 (mat (- (+ (* (e 1 1) (e 2 2) (e 3 3)) (* (e 1 2) (e 2 3) (e 3 1)) (* (e 1 3) (e 2 1) (e 3 2)))
                  (+ (* (e 1 1) (e 2 3) (e 3 2)) (* (e 1 2) (e 2 1) (e 3 3)) (* (e 1 3) (e 2 2) (e 3 1))))
               (- (+ (* (e 0 1) (e 2 3) (e 3 2)) (* (e 0 2) (e 2 1) (e 3 3)) (* (e 0 3) (e 2 2) (e 3 1)))
                  (+ (* (e 0 2) (e 2 3) (e 3 1)) (* (e 0 3) (e 2 1) (e 3 2)) (* (e 0 1) (e 2 2) (e 3 3))))
               (- (+ (* (e 0 1) (e 1 2) (e 3 3)) (* (e 0 2) (e 1 3) (e 3 1)) (* (e 0 3) (e 1 1) (e 3 2)))
                  (+ (* (e 0 1) (e 1 3) (e 3 2)) (* (e 0 2) (e 1 1) (e 3 3)) (* (e 0 3) (e 1 2) (e 3 1))))
               (- (+ (* (e 0 1) (e 1 3) (e 2 2)) (* (e 0 2) (e 1 1) (e 2 3)) (* (e 0 3) (e 1 2) (e 2 1)))
                  (+ (* (e 0 2) (e 1 3) (e 2 1)) (* (e 0 3) (e 1 1) (e 2 2)) (* (e 0 1) (e 1 2) (e 2 3))))
               (- (+ (* (e 1 0) (e 2 3) (e 3 2)) (* (e 1 2) (e 2 0) (e 3 3)) (* (e 1 3) (e 2 2) (e 3 0)))
                  (+ (* (e 1 2) (e 2 3) (e 3 0)) (* (e 1 3) (e 2 0) (e 3 2)) (* (e 1 0) (e 2 2) (e 3 3))))
               (- (+ (* (e 0 0) (e 2 2) (e 3 3)) (* (e 0 3) (e 2 0) (e 3 2)) (* (e 0 2) (e 2 3) (e 3 0)))
                  (+ (* (e 0 0) (e 2 3) (e 3 2)) (* (e 0 2) (e 2 0) (e 3 3)) (* (e 0 3) (e 2 2) (e 3 0))))
               (- (+ (* (e 0 0) (e 1 3) (e 3 2)) (* (e 0 3) (e 1 2) (e 3 0)) (* (e 0 2) (e 1 0) (e 3 3)))
                  (+ (* (e 0 2) (e 1 3) (e 3 0)) (* (e 0 3) (e 1 0) (e 3 2)) (* (e 0 0) (e 1 2) (e 3 3))))
               (- (+ (* (e 0 0) (e 1 2) (e 2 3)) (* (e 0 3) (e 1 0) (e 2 2)) (* (e 0 2) (e 1 3) (e 2 0)))
                  (+ (* (e 0 0) (e 1 3) (e 2 2)) (* (e 0 2) (e 1 0) (e 2 3)) (* (e 0 3) (e 1 2) (e 2 0))))
               (- (+ (* (e 1 0) (e 2 1) (e 3 3)) (* (e 1 3) (e 2 0) (e 3 1)) (* (e 1 1) (e 2 3) (e 3 0)))
                  (+ (* (e 1 0) (e 2 3) (e 3 1)) (* (e 1 1) (e 2 0) (e 3 3)) (* (e 1 3) (e 2 1) (e 3 0))))
               (- (+ (* (e 0 0) (e 2 3) (e 3 1)) (* (e 0 3) (e 2 1) (e 3 0)) (* (e 0 1) (e 2 0) (e 3 3)))
                  (+ (* (e 0 1) (e 2 3) (e 3 0)) (* (e 0 3) (e 2 0) (e 3 1)) (* (e 0 0) (e 2 1) (e 3 3))))
               (- (+ (* (e 0 0) (e 1 1) (e 3 3)) (* (e 0 3) (e 1 0) (e 3 1)) (* (e 0 1) (e 1 3) (e 3 0)))
                  (+ (* (e 0 0) (e 1 3) (e 3 1)) (* (e 0 1) (e 1 0) (e 3 3)) (* (e 0 3) (e 1 1) (e 3 0))))
               (- (+ (* (e 0 0) (e 1 3) (e 2 1)) (* (e 0 3) (e 1 1) (e 2 0)) (* (e 0 1) (e 1 0) (e 2 3)))
                  (+ (* (e 0 1) (e 1 3) (e 2 0)) (* (e 0 3) (e 1 0) (e 2 1)) (* (e 0 0) (e 1 1) (e 2 3))))
               (- (+ (* (e 1 0) (e 2 2) (e 3 1)) (* (e 1 2) (e 2 1) (e 3 0)) (* (e 1 1) (e 2 0) (e 3 2)))
                  (+ (* (e 1 1) (e 2 2) (e 3 0)) (* (e 1 2) (e 2 0) (e 3 1)) (* (e 1 0) (e 2 1) (e 3 2))))
               (- (+ (* (e 0 0) (e 2 1) (e 3 2)) (* (e 0 2) (e 2 0) (e 3 1)) (* (e 0 1) (e 2 2) (e 3 0)))
                  (+ (* (e 0 0) (e 2 2) (e 3 1)) (* (e 0 1) (e 2 0) (e 3 2)) (* (e 0 2) (e 2 1) (e 3 0))))
               (- (+ (* (e 0 0) (e 1 2) (e 3 1)) (* (e 0 2) (e 1 1) (e 3 0)) (* (e 0 1) (e 1 0) (e 3 2)))
                  (+ (* (e 0 1) (e 1 2) (e 3 0)) (* (e 0 2) (e 1 0) (e 3 1)) (* (e 0 0) (e 1 1) (e 3 2))))
               (- (+ (* (e 0 0) (e 1 1) (e 2 2)) (* (e 0 2) (e 1 0) (e 2 1)) (* (e 0 1) (e 1 2) (e 2 0)))
                  (+ (* (e 0 0) (e 1 2) (e 2 1)) (* (e 0 1) (e 1 0) (e 2 2)) (* (e 0 2) (e 1 1) (e 2 0))))))
    (matn
     (mtranspose (mcof m)))))

(declaim (ftype (function (mat) (values mat mat-dim)) mpivot))
(defun mpivot (m)
  ;; FIXME!!
  (values (midentity (mrows m)) 0))

(declaim (ftype (function (mat) (values mat mat mat-dim)) mlu))
(defun mlu (m)
  (etypecase m
    (mat2 (with-fast-matref (e m 2)
            (if (= 0 (mcref m 0 0))
                (if (= 0 (mcref m 1 0))
                    (error "Matrix is singular.")
                    (values (mat (e 1 0) (e 1 1)
                                 (/ (e 0 0) (e 1 0)) (- (e 0 1) (/ (* (e 0 0) (e 1 1)) (e 1 0))))
                            (mat 0 1 1 0)
                            1))
                (values (mat (e 0 0) (e 0 1) (/ (e 1 0) (e 0 0))
                             (- (e 1 1) (/ (* (e 0 1) (e 1 0)) (e 0 0))))
                        (mat 1 0 0 1)
                        0))))
    ;; Not worth the pain to inline it anymore. Just do the generic variant.
    ;; We're using the Crout method for LU decomposition.
    ;; See https://en.wikipedia.org/wiki/Crout_matrix_decomposition
    (mat
     (let* ((c (%rows m)))
       (multiple-value-bind (P s) (mpivot m)
         (let ((LU (m* m P)))
           (with-fast-matrefs ((lu LU c))
             (dotimes (j c)
               (loop for i from 0 to j
                     for sum = (loop for k from 0 below i
                                     sum (* (lu i k) (lu k j)))
                     do (setf (lu i j) (- (lu i j) sum)))
               (loop for i from (1+ j) below c
                     for sum = (loop for k from 0 below j
                                     sum (* (lu i k) (lu k j)))
                     do (setf (lu i j) (/ (- (lu i j) sum) (lu j j))))))
           (values LU P s)))))))

;; TODO
;; QR, eigenvalues
;; upper-triangular
;; lower-triangular
;; diagonal
;; upgrade, downgrade
;; head, tail, left, right, segment, block, corners
